# 最初の一歩

> モナドは「私たちはある決まったやり方でいくらかの追加情報とともに値を持ち回り組合せますが、殆どの関数はそれについて気にしなくていいですよ」と言っています。

現段階では例が無いので追加情報云々がよくわからないが今回の `main` 関数を見てみると `getLine :: IO String` という関数が `IO String` の値を返している。型の変化としてはこの `IO String` の値を矢印 `<-` を通して `args` が受けとり `IO String` の `String` 部分だけとなっている。そして、それを後続の式 `putStrLn ("Hello, " ++ args !! 0)` にこのように渡すことになるが、`"Hello, " ++ ` というのは残りの部分に `String` を要求する関数と見ることができるので、`IO` という部分を気にせずにプログラミングが行えているのがわかる。そして最後にその `String` を受けとった `putStrLn` が `IO ()` に戻す役割をしている。矢印については以下で例が出る。

> name <- action1  
> action2  
>
> 最初の形はaction1の結果を後続のアクションで使えるようnameに束縛します。例えば、もしaction1の型がIO [String] （getArgsのように文字列のリストを返すIOアクション）なら、nameは"bind"演算子>>=によって後続の全てのアクションで持ち回される文字列のリストに束縛されます。二つ目の形はただaction2を実行し、もしあれば次の行に>>演算子を使ってそれを渡します。

いきなり `do` 構文が `>>=` や `>>` の式に変換可能であることの例なども無しに話をし始めた。この辺りですでにこの文章を読むのが不安になったので、このまとめ記事を書こうという決心をした。この前提知識は明らかに

> このチュートリアルの対象読者は主に以下の2種類です。
>   1. LispかSchemeを知っていて、Haskellを学びたい人
>   2. プログラミング言語を何も知らないけれども、一定の背景知識を持っていてコンピュータに詳しい人

に当てはまらない気がする。まずアクションという単語はモナドを利用している関数という考えてよいと思う。更にアクションと呼ばれるものは、単純な値の計算の他にも、私達が単純には認識できない何かを行っているもの、と考える。また `(>>=)` などについてだが今回の `main` 関数は

```haskell
main :: IO ()
-- main = do
--   args <- getArgs
--   putStrLn ("Hello, " ++ args !! 0)
main = getArgs >>= \args -> putStrLn ("Hello, " ++ args !! 0)
```

このように書きかえることができる (`--` 以降の行はコメントを表すので注意)。 `\args -> putStrLn ("Hello, " ++ args !! 0)` はラムダ式になる。また `(>>)` に関して簡単な例を出すと

```haskell
main :: IO ()
main = getLine >> getArgs >>= \args -> putStrLn ("Hello, " ++ args !! 0)
```

この例は完全に無意味なことをしていますが `getLine :: IO String` で入力を受けとるが、その受け取った値は使用せずに後続のアクションを実行している。このようにを何かアクションをするけどその返り値は使わない (その関数が行う何か別なものに目的がある) という場面で使える。

> bind演算子の意味付けは特定のモナドに依存するので、一つのdoブロックの中に異なるモナド型の動作を混在させることはできません。この場合なら、IOモナドのみ使用可能です。

自分は IO モナド以外にほとんど触ったことがなかったのでこれを意識することはこれまで殆どなかった。逆に言えば IO モナドだけなんとなくわかっていれば実際にコマンドライン上のアプリなどを Haskell で書けるとも言えるか。
